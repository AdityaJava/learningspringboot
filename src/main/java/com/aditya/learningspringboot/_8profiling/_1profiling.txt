/********************************************************************************************
 * SPRING PROFILES – COMPLETE NOTES (JAVA / SPRING BOOT)
 *
 * Spring Profiles allow you to segregate configuration and beans
 * based on environments like dev, test, prod, etc.
 *
 * ----------------------------------------------------------------------------
 * 1. application-{profile}.properties / application-{profile}.yaml
 * ----------------------------------------------------------------------------
 *
 * Spring Boot supports profile-specific configuration files.
 *
 * Naming Convention:
 *   application-dev.properties
 *   application-prod.yaml
 *
 * Example:
 *
 * application.yaml (DEFAULT)
 * --------------------------
 * server:
 *   port: 8080
 *
 * spring:
 *   datasource:
 *     url: jdbc:mysql://localhost:3306/default_db
 *
 * application-dev.yaml
 * --------------------
 * server:
 *   port: 8081
 *
 * spring:
 *   datasource:
 *     url: jdbc:mysql://localhost:3306/dev_db
 *
 * application-prod.yaml
 * ---------------------
 * server:
 *   port: 9090
 *
 * spring:
 *   datasource:
 *     url: jdbc:mysql://prod-server:3306/prod_db
 *
 * Spring automatically loads:
 *   - application.yaml (default)
 *   - application-{activeProfile}.yaml
 *
 * ----------------------------------------------------------------------------
 * 2. DEFAULT PROFILE
 * ----------------------------------------------------------------------------
 *
 * If NO profile is explicitly activated:
 *   → Spring uses ONLY application.properties / application.yaml
 *
 * This is considered the "default" configuration.
 *
 * You can explicitly define a default profile:
 *
 * spring:
 *   profiles:
 *     default: dev
 *
 * If spring.profiles.active is NOT set,
 * then 'dev' will be used automatically.
 *
 * ----------------------------------------------------------------------------
 * 3. spring.profiles.active
 * ----------------------------------------------------------------------------
 *
 * spring.profiles.active determines which profile is currently active.
 *
 * Ways to set it:
 *
 * a) application.properties / application.yaml
 *    spring.profiles.active=dev
 *
 * b) JVM argument
 *    -Dspring.profiles.active=prod
 *
 * c) Command line
 *    --spring.profiles.active=prod
 *
 * d) Environment variable
 *    SPRING_PROFILES_ACTIVE=prod
 *
 * ----------------------------------------------------------------------------
 * 4. PROFILE-SPECIFIC VALUES OVERRIDE DEFAULT VALUES
 * ----------------------------------------------------------------------------
 *
 * Priority order (low → high):
 *
 *   application.yaml (default)
 *   application-{profile}.yaml
 *
 * Example:
 *
 * application.yaml
 * ----------------
 * server.port=8080
 *
 * application-dev.properties
 * --------------------------
 * server.port=8081
 *
 * If active profile = dev
 * → Final server.port = 8081
 *
 * Rule:
 *   Profile-specific config ALWAYS overrides default config.
 *
 * ----------------------------------------------------------------------------
 * 5. HOW TO SET PROFILE WHILE RUNNING APPLICATION
 * ----------------------------------------------------------------------------
 *
 * a) Using Maven command (direct)
 *
 * mvn spring-boot:run -Dspring-boot.run.profiles=prod
 *
 * Internally maps to:
 *   spring.profiles.active=prod
 *
 * ------------------------------------------------
 * b) Using Maven <profiles> (PREFERRED & INDUSTRY STANDARD)
 * ------------------------------------------------
 *
 * pom.xml
 * -------
 * <profiles>
 *     <profile>
 *         <id>production</id>
 *         <properties>
 *             <spring.profiles.active>prod</spring.profiles.active>
 *         </properties>
 *     </profile>
 * </profiles>
 *
 * Run command:
 *   mvn spring-boot:run -Pproduction
 *
 * Benefits:
 *   ✔ Clean separation
 *   ✔ CI/CD friendly
 *   ✔ No hardcoding
 *
 * ----------------------------------------------------------------------------
 * 6. @Profile ANNOTATION
 * ----------------------------------------------------------------------------
 *
 * Used to load beans conditionally based on active profile.
 *
 * Example:
 *
 * @Configuration
 * public class DataSourceConfig {
 *
 *     @Bean
 *     @Profile("dev")
 *     public DataSource devDataSource() {
 *         return new HikariDataSource();
 *     }
 *
 *     @Bean
 *     @Profile("prod")
 *     public DataSource prodDataSource() {
 *         return new HikariDataSource();
 *     }
 * }
 *
 * Only beans matching the active profile are created.
 *
 * You can also use:
 *   @Profile({"dev", "test"})
 *
 * ----------------------------------------------------------------------------
 * 7. MULTIPLE PROFILES & OVERRIDING BEHAVIOR
 * ----------------------------------------------------------------------------
 *
 * You can activate multiple profiles:
 *
 * spring.profiles.active=dev,cloud
 *
 * Order matters!
 *
 * Resolution Rule:
 *   LAST profile has highest priority.
 *
 * Example:
 *   spring.profiles.active=dev,prod
 *
 * Override order:
 *   application.yaml
 *   application-dev.yaml
 *   application-prod.yaml   <-- FINAL OVERRIDE
 *
 * Final values come from:
 *   application-prod.yaml
 *
 * NOTE:
 *   This applies to BOTH properties and beans.
 *
 * ----------------------------------------------------------------------------
 * SUMMARY
 * ----------------------------------------------------------------------------
 *
 * ✔ application-{profile}.yaml → profile-specific config
 * ✔ Default config loads when no profile is active
 * ✔ spring.profiles.active controls environment
 * ✔ Profile configs override default configs
 * ✔ Maven <profiles> is preferred in real projects
 * ✔ @Profile controls bean creation
 * ✔ Multiple profiles allowed, LAST one wins
 *
 ********************************************************************************************/
