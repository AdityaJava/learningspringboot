1. OneToMany unidirectional
  - Give theory and example or user and order: user can have many orders
  - Reference exist only in 1 direction i:e from Parent to Child.
  - since 1:MANY, means 1 parent have multiple child and we cannot store multiple child ids in 1 parent row,
           so it creates new table and stores the mapping
  - By default its lazy loading, means when query parents, child rows are not affected.
  - Give working code example and also give how the tables look like
  - (Recommended way) Also give theory and code for other way where I do not want third table and order side can have foreign key from user table.
    like use @JoinColumn and also mention that and highlight that the foreign is there in order table though the @JoinColumn annotation is on
    User table also mention this is not the case in OneToOne.
  - Explain orphan removal in depth

2. OneToMany bidirectional
    - Give theory and example
    - Explain parent side and child side and also owing side and inverseSide and mention that parent is not always the owing side then what is parent?
      give definitions. Like in one to one for user and address the parent is user and child is address and here user holds foreign key so it is parent and
      owing side but in case of OneToMany the Many side or child is owing side give example of user and orders. Parent is business concept like
      without it the existence of child is of no value give your example and analogy chatgpt or correct my understanding
    - And give here JoinColumn on owing side and mappedBy in inverse side
    - We also need @JsonIdentityInfo to avoid recursion.
    - DB structure doesn't change in uni and bidirectional
    - Also here Parent is inverse side and JPA doesn't maintain the foreign key here so when creating orders we also need to set user in. Explain why we need
      to do below
        setOrder(List<Order> orders){
        this.orders = orders;
          for(Order order : orders){
            order.setUser(this);
          }
        }
