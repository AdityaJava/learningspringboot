========================
JPA ARCHITECTURE – END TO END (CORRECTED & DETAILED)
========================

--------------------------------------------------
1. Persistence Unit
--------------------------------------------------
• A Persistence Unit represents a logical database configuration.
• Defined in `persistence.xml` (or auto-configured in Spring Boot).
• It contains:
- DB connection details
- JPA provider (Hibernate)
- Entity classes
- Dialect
- Transaction type

IMPORTANT RULE:
• ONE Persistence Unit creates EXACTLY ONE EntityManagerFactory.

Example:
• If application connects to:
- H2 database
- MySQL database
• Then application will have:
- PersistenceUnit_H2  -> EntityManagerFactory_H2
- PersistenceUnit_MYSQL -> EntityManagerFactory_MYSQL

--------------------------------------------------
2. EntityManagerFactory (EMF)
--------------------------------------------------
• Heavy-weight object
• Created once per Persistence Unit
• Thread-safe
• Expensive to create

Role:
• Used to create MULTIPLE EntityManager instances

Lifecycle:
• Created at application startup
• Destroyed at application shutdown

Example:
EntityManagerFactory emf = Persistence.createEntityManagerFactory("unit1");

--------------------------------------------------
3. EntityManager
--------------------------------------------------
• Light-weight object
• NOT thread-safe
• Represents a SINGLE UNIT OF WORK
• Roughly equivalent to Hibernate Session

CORRECTION:
• EntityManager is NOT "nothing but Hibernate Session"
• Internally Hibernate provides SessionImpl which implements EntityManager

Flow:
Spring Data JPA Repository
↓
EntityManager
↓
Hibernate SessionImpl
↓
JDBC

Example:
repository.save(user)
-> entityManager.persist(user)

--------------------------------------------------
4. EntityManager & Persistence Context
--------------------------------------------------
• EntityManager manages exactly ONE PersistenceContext
• PersistenceContext is a FIRST-LEVEL CACHE
• It stores managed entity objects

PersistenceContext acts as:
• Identity map
• Change tracker
• First-level cache

Key Rule:
• Within the same PersistenceContext:
- Same entity ID → SAME Java object instance

--------------------------------------------------
5. Entity (Entity1 ... EntityN)
--------------------------------------------------
• Entity is a simple POJO annotated with @Entity
• Represents a database table
• Each entity instance represents a row

Example:
@Entity
class User {
@Id
Long id;
String name;
}

Entities are:
• Managed by EntityManager
• Stored inside PersistenceContext when fetched or saved

--------------------------------------------------
6. Example: getUserById Flow
--------------------------------------------------
Step 1:
entityManager.find(User.class, 1)

Step 2:
PersistenceContext is checked FIRST
• If User(id=1) exists → return from cache (NO DB HIT)

Step 3:
If NOT found in PersistenceContext:
• Hibernate generates SQL
• JDBC executes SQL
• ResultSet is mapped to User entity
• User is stored in PersistenceContext
• User is returned

IMPORTANT:
• Second call to find(User, 1) within same transaction
→ NO SQL fired

--------------------------------------------------
7. PersistenceContext = First Level Cache
--------------------------------------------------
• Enabled by default
• Cannot be disabled
• Scope:
- Transaction-scoped (Spring default)

Benefits:
• Prevents duplicate DB calls
• Ensures object identity
• Enables dirty checking

--------------------------------------------------
8. Dirty Checking (Hidden Magic)
--------------------------------------------------
• Hibernate tracks original state of entity
• On transaction commit:
- It compares current state vs original
- Generates UPDATE only if changed

Example:
User u = find(1)
u.setName("NewName")
commit()

→ UPDATE fired WITHOUT calling save()

--------------------------------------------------
9. JPQL (JPA Query Language)
--------------------------------------------------
• Object-oriented query language
• Operates on ENTITY and FIELD names
• NOT table or column names

Example:
SELECT u FROM User u WHERE u.name = :name

JPQL DOES NOT depend on database

--------------------------------------------------
10. Dialect
--------------------------------------------------
MISCONCEPTION FIXED:
• Dialect does NOT translate JPQL → SQL directly

Actual Flow:
JPQL
↓
Hibernate Query Model
↓
Dialect
↓
Database-specific SQL
↓
JDBC

Dialect Responsibilities:
• SQL syntax generation
• Pagination (LIMIT / OFFSET)
• Identity / sequence handling
• Function mapping

Examples:
• MySQLDialect
• H2Dialect
• PostgreSQLDialect

--------------------------------------------------
11. JDBC Limitation
--------------------------------------------------
• JDBC understands ONLY SQL
• JDBC does NOT understand:
- JPQL
- HQL

Hence:
• Dialect is REQUIRED
• Hibernate converts JPQL → SQL before JDBC

--------------------------------------------------
12. Hibernate Internals (SessionImpl)
--------------------------------------------------
• SessionImpl is Hibernate's implementation class
• Implements:
- EntityManager
- Session

Responsibilities:
• Query execution
• PersistenceContext management
• Dirty checking
• Transaction coordination

--------------------------------------------------
13. Complete Flow Summary
--------------------------------------------------
Controller
↓
Service (@Transactional)
↓
Repository (Spring Data JPA)
↓
EntityManager
↓
Hibernate SessionImpl
↓
Dialect
↓
SQL
↓
JDBC
↓
Database

--------------------------------------------------
14. Key Takeaways (Interview Gold)
--------------------------------------------------
• JPA = Specification
• Hibernate = Implementation
• One Persistence Unit → One EntityManagerFactory
• One EntityManager → One PersistenceContext
• PersistenceContext = First-level cache
• JPQL is DB-independent
• Dialect makes Hibernate DB-specific
• JDBC only understands SQL

========================
END
========================
